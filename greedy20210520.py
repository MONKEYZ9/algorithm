n, m = map(int, input().split())

# # 순서대로 북 동 남 서
# # position  = [0, 1, 2, 3]
# # 이걸 위치로 표현하면


# # 바라보는 방향에 따라 왼쪽이 달라진다
# # 북쪽을 바라볼때 왼쪽은 당연히 서쪽
# # 남쪽을 바라볼때 왼쪽은 당연히 동쪽
# # 서쪽을 바라볼때 왼쪽은 당연히 남쪽
# # 동쪽을 바라볼때 왼쪽은 당연히 북쪽

# # 거기가 가본 땅이면 왼쪽으로 돌고 1칸 전진
# # 아니라면 
# # 왼쪽으로만 방향을 돌리기
# # 만약 다 돌았는데 모두 가본칸이거나 바다로 되어있다면 바라보는 방향을 유지한채로 1단계 뒤로 가는데
# # 뒤쪽 방향이 바다면 움직임 홀드

# # direction 은 턴이 될 수록 1을 더하는데 그 값은 0~3을 반복해야함 3이 되면 0으로 바꿔줘야  함
# # 북쪽을 바라볼때 왼쪽은 당연히 서쪽
# # 0 일때 서쪽으로 한칸 가는 것은 dx를 -1하는거 dy는 0
# # 남쪽을 바라볼때 왼쪽은 당연히 동쪽
# # 1 일때 동쪽으로 한칸 가는 것은 dx를 +1하는거 dy는 0
# # 서쪽을 바라볼때 왼쪽은 당연히 남쪽
# # 2 일때 남쪽으로 한칸 가는 것은 dy를 +1하는거 dx는 0
# # 동쪽을 바라볼때 왼쪽은 당연히 북쪽
# # 3 일때 북쪽으로 한칸 가는 것은 dy를 -1하는거 dx는 0

dx = [-1, 0, 1, 0]
dy = [0, -1, 0, 1]

# for _ in range(n) 라고 하면 변수와는 상관없이 n번 반복하는거
# d = [[0] * 4] 하면 [[0, 0, 0, 0]]
# [1, 2, 3] * 3
# [1, 2, 3, 1, 2, 3, 1, 2, 3]
# d = [[0] * m for _ in range(n)]
# print(d) 이렇게 함으로 지도에 가본적이 없는 곳으로 만들고

# 현재 캐릭터의 위치와 방향을 받아야해
x, y, direction = map(int, input().split())

d = []

for i in range(n):
   d.append(list(map(int, input().split())))

# d[x][y] = 1

# 주변이 모두 1일때까지 왔다 갔다 할거고
# 일단 갔는데 주변에 모두 1이면 다시 뒤돌건데 거기도 1이겠지
# 0이면 가는거지
# 일단 고개가 어딘지에 따라 앞으로 나아가는거니까
# dx dy를 잘보고 가자

# 0 -> 1로 바꾼 횟수
zeroToOne_count = 0
# 바깥으로 나가도 안돼
# 가려고 하는 방향이 0인지 확인해야해
# 갔는데 1이면 가면 안돼
# 앞으로 가 그럼 2가 되게 그럼 2라면 다시 되돌아도면서 1로 만들고 와야지

# 아님 앞이 0이라면 가자 아님 direction을 +1 하고
# 멈추는 조건은 모든 앞이 0이 아니라면 break
# d[x] = d[x + dx[0]] #1 + -1 d[0][1] = 가로축은 모두 x 세로축은 모두 y
# d[y] = d[y + dy[0]] #1 + 0
# print(d[x][y])

while True:
      if direction == 0:
         d[x] = d[x + dx[0]]
         d[y] = d[y + dy[0]]
         if d[x][y] == 1:
            direction += 1
            d[x] = d[x - dx[0]]
            d[y] = d[y - dy[0]]
            if direction == 1:
               d[x] = d[x + dx[1]]
               d[y] = d[y + dy[1]]
               if d[x][y] == 1:
                  direction += 1
                  d[x] = d[x - dx[1]]
                  d[y] = d[y - dy[1]]
                  if direction == 2:
                     d[x] = d[x + dx[2]]
                     d[y] = d[y + dy[2]]
                     if d[x][y] == 1:
                        direction += 1
                        d[x] = d[x - dx[2]]
                        d[y] = d[y - dy[2]]
                        if direction == 3:
                           d[x] = d[x + dx[3]]
                           d[y] = d[y + dy[3]]
                           if d[x][y] == 1:
                              break
         else:
            d[x][y] = 1
            zeroToOne_count += 1
            direction += 1
            
# 이건 아닌거 같다 책을 안보고 최대한 하려고 했는데 너무 우후죽순으로 된다
# 내일 다시 해보자
